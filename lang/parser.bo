module parser

import lexer
import ../std/strings


type Operator {
    OpPlus
    OpMinus
    OpTimes
    OpDivide
    OpModulo
    OpLT
    OpGT
    OpLTEq
    OpGTEq
    OpEqEq
    OpOrOr
    OpAndAnd
    OpNotEq
    OpNot
}

fn string(op Operator) string
    switch op
        OpPlus  ; return "+"
        OpMinus ; return "-"
        OpTimes ; return "*"
        OpDivide; return "/"
        OpModulo; return "%"
        OpLT    ; return "<"
        OpGT    ; return ">"
        OpLTEq  ; return "<="
        OpGTEq  ; return ">="
        OpEqEq  ; return "=="
        OpOrOr  ; return "||"
        OpAndAnd; return "&&"
        OpNotEq ; return "!="
        OpNot   ; return "!"


type Expr {
    ExprIdent : string
    ExprInt   : i64
    ExprFloat : f64
    ExprInfix : (Operator, Expr, Expr)
}

fn string(e Expr) string
    switch e
        ExprIdent(str); return "ident: " + str
        ExprInt(n)    ; return "int: " + string(n)


type Node {
    : Operator
    : Expr
    : [Node]
    NodeEmpty
}

fn string(n Node) string
    switch(n)
        Operator(o); return string(o)
        Expr(e)    ; return string(e)


type ParseResult [ ( Node, [Token] ) ]

fn string(p ParseResult) string
    return string(len(p)) + " parse results"

fn ||(a ParseResult, b ParseResult) ParseResult
    let r = copy(a) 
    r <<- copy(b)
    return r


fn parseEpsilon(tokens [Token]) parser.ParseResult
    return [ (NodeEmpty, tokens) ]


fn parseOperator(tokens [Token]) ParseResult
    switch tokens
        TokOp("+") -> ts; return [(Node(OpPlus), ts)]
        TokOp("-") -> ts; return [(Node(OpMinus), ts)]
        _               ; return []


fn parseExpr_(tokens [Token]) ParseResult
    return []
    switch parseOperator(tokens)
        (n, ts) -> _;

        


fn parseIdent(tokens [Token]) ParseResult
    if tokens # TokIdent(s) -> ts
        return [ (Node(ExprIdent(s)), ts) ]
    return []


fn parseInt(tokens [Token]) ParseResult
    switch tokens
        TokInt(n) -> ts; return [ (Node(ExprInt(n)), ts) ]
        _              ; return []
    

fn parseTerm(tokens [Token]) ParseResult 
    switch tokens
        TokInt(n) -> ts  ; return [ (Node(ExprInt(n)), ts) ]
        TokIdent(s) -> ts; return [ (Node(ExprIdent(s)), ts) ]
        _                ; return []


