module parser

import lexer
import ../std/strings


type Operator {
    OpPlus
    OpMinus
    OpTimes
    OpDivide
    OpModulo
    OpLT
    OpGT
    OpLTEq
    OpGTEq
    OpEqEq
    OpOrOr
    OpAndAnd
    OpNotEq
    OpNot
}

fn string(op Operator) string
    switch op
        OpPlus  ; return "+"
        OpMinus ; return "-"
        OpTimes ; return "*"
        OpDivide; return "/"
        OpModulo; return "%"
        OpLT    ; return "<"
        OpGT    ; return ">"
        OpLTEq  ; return "<="
        OpGTEq  ; return ">="
        OpEqEq  ; return "=="
        OpOrOr  ; return "||"
        OpAndAnd; return "&&"
        OpNotEq ; return "!="
        OpNot   ; return "!"


type Expr {
    ExprIdent : string
    ExprInt   : i64
    ExprFloat : f64
    ExprInfix : (Operator, Expr, Expr)
}

fn string(e Expr) string
    switch e
        ExprIdent(str); return "ident: " + str
        ExprInt(n)    ; return "int: " + string(n)


type Node {
    : Operator
    : Expr
}

fn string(n Node) string
    switch(n)
        Operator(o); return string(o)
        Expr(e)    ; return string(e)


type ParseResult [ ( Node, [Token] ) ]

fn string(p ParseResult) string
    return string(len(p)) + " parse results"


fn concatParseResults(results [ParseResult]) ParseResult
    let result = ParseResult()
    let i = 0
    while i < len(results)
        result = append(result, results[i])
        


fn parseToken(tokens [Token], tok Token, result Node) ParseResult
    if tokens -> [t] .. | t == tok
        return ParseResult( [ (result, tokens[1..]) ] )
    return []


fn parseAny(tokens [Token], fns [ fn ([Token]) ParseResult ]) ParseResult
    let r = ParseResult()
    let i = 0
    while i < len(fns)
        r = append(r, fns[i](tokens))
        i = i + 1
    return r


fn parseOperator(tokens [Token]) ParseResult
    let results = [
        parseToken(tokens, TokOp("+"), Node(OpPlus)),
        parseToken(tokens, TokOp("-"), Node(OpMinus)),
        parseToken(tokens, TokOp("*"), Node(OpTimes)),
        parseToken(tokens, TokOp("/"), Node(OpDivide))
    ]
    concatParseResults(results)

