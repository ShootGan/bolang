module parser

import lexer
import ../std/strings


type Operator {
    OpPlus
    OpMinus
    OpTimes
    OpDivide
    OpModulo
    OpLT
    OpGT
    OpLTEq
    OpGTEq
    OpEqEq
    OpOrOr
    OpAndAnd
    OpNotEq
    OpNot
}

fn string(op Operator) string
    switch op
        OpPlus  ; return "+"
        OpMinus ; return "-"
        OpTimes ; return "*"
        OpDivide; return "/"
        OpModulo; return "%"
        OpLT    ; return "<"
        OpGT    ; return ">"
        OpLTEq  ; return "<="
        OpGTEq  ; return ">="
        OpEqEq  ; return "=="
        OpOrOr  ; return "||"
        OpAndAnd; return "&&"
        OpNotEq ; return "!="
        OpNot   ; return "!"


type Expr {
    ExprIdent : string
    ExprInt   : i64
    ExprFloat : f64
    ExprInfix : (Operator, Expr, Expr)
}

fn string(e Expr) string
    switch e
        ExprIdent(str); return "ident: " + str
        ExprInt(n)    ; return "int: " + string(n)


type Node {
    : Operator
    : Expr
}

fn string(n Node) string
    switch(n)
        Operator(o); return string(o)
        Expr(e)    ; return string(e)


type ParseResult [ ( Node, [Token] ) ]

fn string(p ParseResult) string
    return string(len(p)) + " parse results"


fn concatParseResults(results [ParseResult]) ParseResult
    let result = ParseResult()
    let i = 0
    while i < len(results)
        result = append(result, results[i])
        


fn parseToken(tokens [Token], tok Token, result Node) ParseResult
    if tokens -> [t] .. | t == tok
        return ParseResult( [ (result, tokens[1..]) ] )
    return []


fn parseOperator(tokens [Token]) (Operator, [Token])
    switch tokens[0]
        TokOp("+") ; return (OpPlus,   tokens[1..])
        TokOp("-") ; return (OpMinus,  tokens[1..])
        TokOp("*") ; return (OpTimes,  tokens[1..])
        TokOp("/") ; return (OpDivide, tokens[1..])
        TokOp("%") ; return (OpModulo, tokens[1..])
        TokOp("<") ; return (OpLT,     tokens[1..])
        TokOp(">") ; return (OpGT,     tokens[1..])
        TokOp("<="); return (OpLTEq,   tokens[1..])
        TokOp(">="); return (OpGTEq,   tokens[1..])
        TokOp("=="); return (OpEqEq,   tokens[1..])
        TokOp("||"); return (OpOrOr,   tokens[1..])
        TokOp("&&"); return (OpAndAnd, tokens[1..])
        TokOp("!="); return (OpNotEq,  tokens[1..])
        TokOp("!") ; return (OpNot,    tokens[1..])

