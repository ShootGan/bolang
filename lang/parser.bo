module parser

imports lexer
imports ../std/strings


type Operator {
    null
    OpPlus
    OpMinus
    OpTimes
    OpDivide
    OpModulo
    OpLT
    OpGT
    OpLTEq
    OpGTEq
    OpEqEq
    OpOrOr
    OpAndAnd
    OpNotEq
    OpNot
}


type Expr {
    null
    ExprIdent : string
    ExprInt   : i64
    ExprFloat : f64
    ExprInfix : (Operator, Expr, Expr)
}


fn string(e Expr) string
    switch e
        null          ; return "null"
        ExprIdent(str); return "ident: " + str
        ExprInt(n)    ; return "int: " + string(n)



fn parseOperator(tokens [Token]) (Operator, [Token])
    if len(tokens) < 1
        return (null, tokens)

    switch tokens[0]
        TokOp("+") ; return (OpPlus,   tokens[1..])
        TokOp("-") ; return (OpMinus,  tokens[1..])
        TokOp("*") ; return (OpTimes,  tokens[1..])
        TokOp("/") ; return (OpDivide, tokens[1..])
        TokOp("%") ; return (OpModulo, tokens[1..])
        TokOp("<") ; return (OpLT,     tokens[1..])
        TokOp(">") ; return (OpGT,     tokens[1..])
        TokOp("<="); return (OpLTEq,   tokens[1..])
        TokOp(">="); return (OpGTEq,   tokens[1..])
        TokOp("=="); return (OpEqEq,   tokens[1..])
        TokOp("||"); return (OpOrOr,   tokens[1..])
        TokOp("&&"); return (OpAndAnd, tokens[1..])
        TokOp("!="); return (OpNotEq,  tokens[1..])
        TokOp("!") ; return (OpNot,    tokens[1..])
        _          ; return (null,     tokens)


fn parseExpr(tokens [Token]) Expr
    if len(tokens) < 1
        return null
    

