module lexer

imports ../std/io
imports ../std/strings
imports ../std/chars

type Token {
    null
    TokOp      string
    TokInt     i64
    TokSym     char
    TokIdent   string
    TokString  string
    TokKeyword string
}

let keywords  = ["let", "while", "fn", "extern", "true", "false", "null", "if", "else", "return", "module", "imports"]
let types     = ["i8", "i16", "i32", "i64", "char", "bool", "string"]
let operators = ["+", "-", "*", "/", "%", "=", "+=", "-=", "*=", "/=", "%=", "..", "<", ">", "<=", ">=", "&&", "||", "=="]
let symbols   = ['(', ')', '[', ']', '{', '}', ':']


fn lexString(str string) (Token, string)
    if len(str) == 0 || str[0] != '"'
        return (null, str)

    let i = 1
    while i < len(str) && (isAlpha(str[i]) || isDigit(str[i]))
        i = i + 1

    if i < len(str) && str[i] == '"'
        return (TokString(str[1..i]), str[(i+1)..])

    return (null, str)


fn lexSymbol(str string) (Token, string)
    if len(str) == 0
        return (null, str)

    let i = 0
    while i < len(symbols)
        if str[0] == symbols[i]
            return (TokSym(str[0]), str[1..])
        i = i + 1

    return (null, str)


fn lexKeyword(str string) (Token, string)
    let (i, k) = (0, 0)

    while i < len(str) && isAlpha(str[i])
        i = i + 1

    let word = str[..i]
    while k < len(keywords)
        if strEqual(word, keywords[k])
            return (TokKeyword(word), str[i..])
        k = k + 1

    return (null, str)

fn lexDigits(str string) (Token, string)
    let i = 0
    while i < len(str) && isDigit(str[i])
        i = i + 1
    
    switch strReadInt(str[..i])
        null   ; return (null, str)
        i64(n) ; return (TokInt(n), str[i..])


fn lexIdent(str string) (Token, string)
    let i = 0

    if i >= len(str) || !isAlpha(str[i])
        return (null, str)

    while i < len(str) && (isDigit(str[i]) || isAlpha(str[i]))
        i = i + 1

    return (TokIdent(str[..i]), str[i..])


fn lexOperator(str string) (Token, string)
    let (i, j, max) = (0, 0, 0)

    while i < len(operators)
        if isPrefix(operators[i], str) && len(operators[i]) > max
            max = len(operators[i])
            j = i
        i = i + 1
    
    switch max
        0; return (null, str)
        n; return (TokOp(operators[j]),  str[n..])


fn lexWhite(str string) string
    let i = 0
    while i < len(str) && (str[i] == ' ' || str[i] == '\t' || str[i] == '\n')
        i = i + 1

    return str[..i]


fn lexToken(str string) (Token, string)
    switch lexWhite(str)
        s | len(s) > 0; return lexToken(str[len(s)..])
        _             ;

    switch lexKeyword(str)
        (null, _) ;
        (tok, ss) ; return (tok, ss)

    switch lexString(str)
        (null, _) ;
        (tok, ss) ; return (tok, ss)

    switch lexIdent(str)
        (null, _) ;
        (tok, ss) ; return (tok, ss)

    switch lexOperator(str)
        (null, _) ;
        (tok, ss) ; return (tok, ss)

    switch lexDigits(str)
        (null, _) ;
        (tok, ss) ; return (tok, ss)

    switch lexSymbol(str)
        (null, _) ;
        (tok, ss) ; return (tok, ss)

    return (null, str)




            
    
